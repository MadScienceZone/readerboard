#!/usr/bin/python3
#
# Usage: ./mkfont fontfile0 fontfile1 ... > fonts.ino
#
# The source data for each font has the form:
# [<codepoint> <name>]
# ..@@@@...@|
# ..@@@@...@|   .=0 @=1 |=inter-character space
# ..@@@@...@|
#
# Columns containing |s must consist of nothing but | and all columns
# to the right must also be just | columns. These indicate how much
# inter-character space to make after the character when it's printed
# but those columns are NOT stored in the bitmap array.  A column of
# just .s would display as a blank column but WILL be stored as 0s in
# the bitmap array.
#
# or
#
# ->codepoint
# to reuse another glyph in this position too. (The bitmap is not
# stored again; this code position in this font will simply point
# to the other character's bitmap.)
#
# ->codepoint,fontID
# allows you to reuse a glyph from another font.
#
# If a character starts with
# [default]
# then the glyph will be used for all undefined character positions
# within the font's defined range of codepoints [0,max]
#
# Steve Willoughby 2023

import re
import sys

class FontMetric:
    def __init__(self, codepoint, name, offset, width=None, space=None):
        self.codepoint = codepoint
        self.name = name
        self.offset = offset
        self.space = space
        self.width = width
        self.alias_for = None
        self.alias_font = None

    def set_alias(self, alias_for, alias_font=None):
        self.alias_for = alias_for
        self.alias_font = alias_font

font_data = []
bitmap_data = []
char_breaks = []
default_glyph = None

print('#include "fonts.h"')
print('/* Generated font data')
for font_id, font_source in enumerate(sys.argv[1:]):
    print(f' *   Font #{font_id} generated from {font_source}')
    metric_data = {}
    with open(font_source) as src:
        for line in src:
            if not line.strip():
                continue

            if re.match(r'^\s*;', line):
                continue

            if line.strip() == '[default]':
                if default_glyph is not None:
                    raise ValueError(f"default glyph defined multiple times in font {font_id} ({font_source})")
                default_glyph = this_metric = FontMetric(None, "default glyph", len(bitmap_data))
                char_width = None
                codepoint = None
                charname = "default glyph"
                continue

            if m := re.match(r'^\s*\[(?:\$([0-9a-fA-F]{1,2})|(\d+))(.*)\]\s*$', line):
                if m.group(1):
                    codepoint = int(m.group(1), 16)
                elif m.group(2):
                    codepoint = int(m.group(2))
                else:
                    raise ValueError(f"missing or invalid codepoint in font {font_id} ({font_source}); must be $<hex> or <decimal>")

                charname = m.group(3).strip()
                if codepoint in metric_data:
                    raise ValueError(f"duplicate entry for codepoint {codepoint} ({charname}) in font {font_id} ({font_source})")

                metric_data[codepoint] = this_metric = FontMetric(codepoint, charname, len(bitmap_data))
                char_width = None
                continue

            if not metric_data and default_glyph is None:
                raise ValueError("character definition before any character started")

            if m := re.match(r'^\s*->\s*(?:\$([0-9a-fA-F]{1,2})|(\d+))(?:,\s*(\d+))?\s*$', line):
                if m.group(1):
                    codepoint = int(m.group(1), 16)
                elif m.group(2):
                    codepoint = int(m.group(2))
                else:
                    raise ValueError(f"missing or invalid alias codepoint in font {font_id} ({font_source}); must be $<hex> or <decimal>")
                if this_metric.alias_for is not None:
                    raise ValueError(f"multiple aliases given for codepoint {codepoint} ({charname}) in font {font_id} ({font_source})")
                if this_metric.space is not None:
                    raise ValueError(f"alias and character bitmap given for codepoint {codepoint} ({charname}) in font {font_id} ({font_source})")

                if m.group(3):
                    this_metric.set_alias(codepoint, int(m.group(3)))
                else:
                    this_metric.set_alias(codepoint)
                continue

            if this_metric.alias_for is not None:
                raise ValueError(f"alias and character bitmap given for codepoint {codepoint} ({charname}) in font {font_id} ({font_source})")

            line = re.sub(r'[^.@|]', '', line)
            if this_metric.space is None:
                char_width = this_metric.space = len(line)
                this_bit = 0x01
                for pos, symbol in enumerate(line):
                    if symbol == '|':
                        char_width = pos
                        break
                bitmap_data.extend([0]*char_width)
                this_metric.width = char_width

            elif len(line) != this_metric.space:
                raise ValueError(f"inconsistent character width in font {font_id} ({font_source}), character {codepoint} ({charname})")

            else:
                this_bit <<= 1
                if this_bit > 0x80:
                    raise ValueError(f"too many rows in font {font_id} ({font_source}), character {codepoint} ({charname})")

            for pos, symbol in enumerate(line):
                if symbol == '|':
                    if pos < char_width:
                        raise ValueError(f"unexpected '|' at position {pos} in font {font_id} ({font_source}), character {codepoint} ({charname})")
                else:
                    if pos >= char_width:
                        if pos >= this_metric.space:
                            raise ValueError(f"too many bits in font {font_id} ({font_source}), character {codepoint} ({charname})")
                        raise ValueError(f"unexpected bit (expected '|') at position {pos} in font {font_id} ({font_source}), character {codepoint} ({charname})")
                    if symbol == '@':
                        bitmap_data[this_metric.offset+pos] |= this_bit
                    elif symbol != '.':
                        raise ValueError(f"unexpected bit symbol '{symbol}' at position {pos} in font {font_id} ({font_source}), character {codepoint} ({charname})")
    font_data.append(metric_data)
print(' */')

print(f'''
/* font definitions */
const int N_FONTS = {len(font_data)};

const word FontMaxCodepoint[N_FONTS] = {{{', '.join([str(max(f.keys())) for f in font_data])}}};

''')

glyph_lengths = []
glyph_spaces = []
glyph_offsets = []

for font_id, font in enumerate(font_data):
    font_lengths = []
    font_spaces = []
    font_offsets = []

    #print(f'const PROGMEM FontMetrics GlyphMetricDataFont{font_id}[{max(font_data[font_id].keys())+1}] = {{')
    last_codepoint = -1
    for codepoint in sorted(font):
        metric = font[codepoint]
        while codepoint > last_codepoint+1:
            last_codepoint += 1
            if default_glyph is None:
                font_lengths.append(0)
                font_spaces.append(0)
                font_offsets.append(0)
                #print(f'  {{0,  0,     0}}, // {font_id} {last_codepoint:03d} ${last_codepoint:02X} <undefined>')
            else:
                font_lengths.append(default_glyph.width)
                font_spaces.append(default_glyph.space)
                font_offsets.append(default_glyph.offset)
                #print(f'  {{{default_glyph.width}, {default_glyph.space:2d}, {default_glyph.offset:5d}}}, // {font_id} {last_codepoint:03d} ${last_codepoint:02X} <undefined>')
        last_codepoint = codepoint

        include_break = True
        while metric.alias_for is not None:
            include_break = False
            if metric.alias_font is None:
                af = font
            else:
                af = font_data[metric.alias_font]

            if metric.alias_for not in af:
                raise ValueError(f"codepoint {codepoint} ({metric.name}) in font {font_id} aliased to codepoint {metric.alias_for} which does not exist")
            metric = af[metric.alias_for]

        if metric.width == 0:
            font_lengths.append(0)
            font_spaces.append(metric.space)
            font_offsets.append(0)
            #print(f'  {{0, {metric.space:2d},     0}}, // {font_id} {codepoint:03d} ${codepoint:02X} {metric.name}')
        else:
            font_lengths.append(metric.width)
            font_spaces.append(metric.space)
            font_offsets.append(metric.offset)
            #print(f'  {{{metric.width}, {metric.space:2d}, {metric.offset:5d}}}, // {font_id} {codepoint:03d} ${codepoint:02X} {metric.name}')
        if metric.offset > 0 and metric.width and metric.alias_for is None:
            if include_break:
                char_breaks.append(metric.offset)
    #print('};')
    glyph_lengths.append(font_lengths)
    glyph_spaces.append(font_spaces)
    glyph_offsets.append(font_offsets)

if len(glyph_lengths) != len(glyph_spaces) or len(glyph_spaces) != len(glyph_offsets):
    raise ValueError('inconsistent glyph array lengths! BUG!!')

for font_id, fgl in enumerate(glyph_lengths):
    print(f'const PROGMEM byte GlyphMetricDataFont{font_id}Lengths[{len(fgl)}] = {{')
    for li, l in enumerate(fgl):
        if li > 0 and li % 20 == 0:
            print()
        print(f'{l:2d}, ', end='')
    print('};')

for font_id, fgs in enumerate(glyph_spaces):
    print(f'const PROGMEM byte GlyphMetricDataFont{font_id}Spaces[{len(fgs)}] = {{')
    for li, l in enumerate(fgs):
        if li > 0 and li % 20 == 0:
            print()
        print(f'{l:2d}, ', end='')
    print('};')

for font_id, fgo in enumerate(glyph_offsets):
    print(f'const PROGMEM word GlyphMetricDataFont{font_id}Offsets[{len(fgo)}] = {{')
    for li, l in enumerate(fgo):
        if li > 0 and li % 10 == 0:
            print()
        print(f'{l:5d}, ', end='')
    print('};')

#print(f'const PROGMEM FontMetrics * const GlyphMetricData[{len(font_data)}] = {{{", ".join([f"GlyphMetricDataFont{i}" for i in range(len(font_data))])}}};')
print(f'const byte * const GlyphMetricDataLengths[{len(font_data)}] = {{{", ".join([f"GlyphMetricDataFont{i}Lengths" for i in range(len(font_data))])}}};')
print(f'const byte * const GlyphMetricDataSpaces[{len(font_data)}] = {{{", ".join([f"GlyphMetricDataFont{i}Spaces" for i in range(len(font_data))])}}};')
print(f'const word * const GlyphMetricDataOffsets[{len(font_data)}] = {{{", ".join([f"GlyphMetricDataFont{i}Offsets" for i in range(len(font_data))])}}};')

if default_glyph is not None and default_glyph.offset != 0:
    char_breaks.append(default_glyph.offset)
char_breaks.append(len(bitmap_data))

print('/* font bitmap data */')
print(f'const PROGMEM byte CharacterBitmap[{len(bitmap_data)}] = {{')
start_pos = 0
for break_pos in sorted(char_breaks):
    print(' ' + ' '.join([f'0x{b:02X},' for b in bitmap_data[start_pos:break_pos]]))
    print(' '*40, f'// {start_pos} - {break_pos-1}')
    for bit in range(8):
        print(' '*40, '//     ', end='')
        for col in bitmap_data[start_pos:break_pos]:
            if col & (1 << bit) :
                print('@', end='')
            else:
                print('.', end='')
        print()
    start_pos = break_pos
print('};')
print(f'''

bool get_font_metric_data(byte font, byte codepoint, byte *leng, byte *space, unsigned int *offset)
{{
    if (font >= N_FONTS || codepoint > FontMaxCodepoint[font]
    || leng == NULL || space == NULL || offset == NULL)
        return false;

    *leng = pgm_read_byte_far(GlyphMetricDataLengths[font] + codepoint);
    *space = pgm_read_byte_far(GlyphMetricDataSpaces[font]  + codepoint);
    *offset = (unsigned int) pgm_read_word_far(GlyphMetricDataOffsets[font] + codepoint);

    return true;
}} 

byte get_font_bitmap_data(unsigned int offset) 
{{
    if (offset < 0 || offset >= {len(bitmap_data)})
        return 0;
    return pgm_read_byte_far(CharacterBitmap + offset);
}}
''')
